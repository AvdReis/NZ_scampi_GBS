#PACKAGES#
library(dplyr)
library(tidyr)
library(ncdf4)
library(marmap)
library(ggplot2)

#load raw data
matlab <- "C:/path/to/data/particle_modelling.nc"

#open a netCDF file
ncin <- nc_open(matlab)
print(ncin)

#get longitude
lon <- ncvar_get(ncin,"lon")
dim(lon)

#get latitude
lat <- ncvar_get(ncin,"lat")
dim(lat)

#depending how the different status' were defined - 0: active particle, 1: particle left the domain, 2: particle is onland, 3: particle has been caught
status <- ncvar_get(ncin,"status")
dim(status)

#status
m1 <- as.matrix(status)

no_col <- as.data.frame(rep(1:n)) #n = this will very with the size of your dataframe
no_col$col <- no_col$`rep(1:n)` 

#Extract particles that had status 1
no_one <- as.data.frame(which(m1==1, arr.ind=TRUE))

#Extract particles that had status 2
no_two <- as.data.frame(which(m1==2, arr.ind=TRUE))

#Extract particles that had status 3
no_three <- as.data.frame(which(m1==3, arr.ind=TRUE))

#Extract particles that are still active or did not start - ensuring all particles are accounted for!
no_zero <- anti_join(no_col, no_one)
no_zero <- anti_join(no_zero, no_two)
no_zero <- anti_join(no_zero, no_three)

#identifying row and column where first '0' is - this is when the particle would have been released
m1 <- as.matrix(status)

rnc_start <- which(m1==0, arr.ind=TRUE)
rnc_start <- as.data.frame(rnc_start)
rnc_start <- rnc_start %>% group_by(col) %>% filter(row_number()==1)
rnc_start <- as.matrix(rnc_start) #coords of start for each particle

#creating dataframe that has row and columns to make a reference when join start and finish
start_data <- as.data.frame(rnc_start)

#extract lat and long of starting points
start_data$lat_s <- lat[rnc_start]
start_data$lon_s <- lon[rnc_start]

start_data$status <- rep(0)

#see what is happening to the particles unaccounted for
missing <- data.frame(rep(1:n)) #n = this will very with the size of your dataframe
missing$col <- missing$rep.1.n.
missing <- anti_join(missing, start_data) #ID particles that never became active
#lat[, 36756] #some particles just never started 

#=======================================================================================================================#
#Not all particles were released within their defined boxes and this section is specifically for this articles which can be adapted for your own work
#As best possible all particles were assigned to a release location (fishery management unit) dependant on geographic coordinates

#CR#
start_data$start_location <- if_else(start_data$lat_s > -45 & start_data$lat_s < -35 & start_data$lon_s < 173, "WC", if_else(start_data$lat_s > -55 & start_data$lat_s < -45, "AI", if_else(start_data$lat_s > -38 & start_data$lat_s & start_data$lon_s > 173, "UNI", if_else(start_data$lat_s < -42.6, "CR", "LNI"))))

#AI, WC, UNI, LNI#
start_data$start_location <- if_else(start_data$lat_s > -45 & start_data$lat_s < -35 & start_data$lon_s < 173, "WC", if_else(start_data$lat_s > -55 & start_data$lat_s < -45, "AI", if_else(start_data$lat_s > -38 & start_data$lat_s & start_data$lon_s > 173, "UNI", if_else(start_data$lat_s < -42.6, "CR", "LNI"))))
#separate CR and LNI#
not_CR_LNI <- filter(start_data, start_location != "CR" & start_location != "LNI")
CR_LNI <- filter(start_data, start_location != "AI" & start_location != "WC", start_location != "UNI")

CR_LNI$start_location <- if_else(CR_LNI$lat_s < -42 & CR_LNI$lon_s < 177.5, "CR", CR_LNI$start_location)

CR_LNI$start_location <- if_else(CR_LNI$lat_s > -42.49802 & CR_LNI$lon_s > 177.0999, "LNI", CR_LNI$start_location)

start_data <- rbind(not_CR_LNI, CR_LNI)

#LNI only#
start_data$start_location <- if_else(start_data$start_location == "LNI", "CR", start_data$start_location)

table(start_data$status, start_data$start_location)
#=======================================================================================================================#

#identifying row and column where 'caught' is, as these are the particles that are most interesting
rnc_end <- which(m1==3, arr.ind=TRUE) #may not be assigned to '3' as caught

end_data <- as.data.frame(rnc_end)

end_data$lat_f <- lat[rnc_end]
end_data$lon_f <- lon[rnc_end]

#end_data$lon_f <- 180 + (180 - (end_data$lon_f * -1)) #specifically for my data

end_data$status <- rep(3) #may not be assigned to '3'

#join data together
#this way can check stats
start_end_data <- left_join(end_data, start_data,  by = "col")

table(start_end_data$start_location, start_end_data$status.y)

#MEAN TIME BEFORE CAUGHT#
#count how long on average particles took from getting released to getting caught
#here you need to know how often the particles coords were captured
time <- t(status)
time <- as.data.frame(time)
time$col <- rep(1:n)

end_data_time <- end_data[,1:2]

time <- left_join(end_data_time, time)
time$count_zero <- apply(time, 1, function(x) length(which(x==0))) #count how many zeros there are in a column
time$count_zero <- time$count_zero+1 #plus 1 for not counting '3'

head(time$count_zero)

area <- start_end_data[,c(2,10)] #may need to be adjusted according to data

time_area <- time[,c(2,524)]
time_area <- left_join(area, time_area)
aggregate(count_zero ~ start_location, time_area, FUN = mean) #if there is min mean max etc in the global env the fun will not work rm(min/max) from global env

time_area %>% filter(start_location == "location_A") %>% filter(count_zero == 46)
error_std <- time_area %>% filter(start_location == "location_A")

#--------------------#
std <- function(x) sd(x)/sqrt(length(x))
se <- function(x) sqrt(var(x)/length(x))
#--------------------#

std(error_std$count_zero)
se(error_std$count_zero)

##########################################################################################
####MAKE A MOVING MAP####

#good tutorial to help understand that package - http://movevis.org/articles/example-1.html

#this cool R package animates your particles path, but required quite a bit of tweaking to get the correct input df
library(moveVis)
library(move)
library(raster)
library(ggplot2)

All_random_pick <- start_data %>% group_by(start_location) %>% sample_n(100) #choosing 100 particles
#could use start_end_data if wanted to have only those particles that were caught

location_A <- filter(All_random_pick, start_location == "location_A") #here I am interested in all particles that started from a specific location - making the viewing easier

#extracting the latitude path
caught_lat <- as.data.frame(lat[,location_A$col])
path_caught_lat <- gather(caught_lat, key = V, "latitude_path") #making one large df
path_caught_lat <- filter(path_caught_lat, latitude_path < 0)

#extracting the longitude path
caught_lon <- as.data.frame(lon[,WC$col])
path_caught_lon <- gather(caught_lon, key = V, "longitude_path")
path_caught_lon <- filter(path_caught_lon, longitude_path < 200) #making one large df

path_data <- cbind(path_caught_lat, path_caught_lon)
path_data <- path_data[,c(2, 4, 1)]

#bind columns together separated by ';'
path_data$join <- paste(path_data$latitude_path, path_data$longitude_path, sep = ";")

test <- path_data %>% group_by(V) %>% mutate(observation = 1:n())
test <- test[,c(5,3,4)] #reordering columns

y <- pivot_wider(test, names_from = V, values_from = join)

x <- pivot_longer(y, 2:101, names_to = "V")

a <- x %>% group_by(V) %>% mutate(y4=zoo::na.locf(value))

b <- a[,c(1,2,4)]

c <- pivot_wider(b, names_from = V, values_from = y4) 
#c <- c[1:n,] #can shorten number of rows two the average rows per column - smaller number of frames

#need to have the correct timestamp format
c$timestamp <- as.POSIXct("2016-01-01 00:00:00") + sort(sample(1:n)) #n = number of rows

d <- pivot_longer(c, 2:101, names_to = "V")
d <- separate(d, 4, c("x", "y"), sep = ";")

d$x <- as.numeric(d$x)
d$y <- as.numeric(d$y)

#to maintain in working box for New Zealand maps
#if making a static map these points can be plotted if changed to go 180+
#otherwise it does seem to be possible - https://github.com/16EAGLE/moveVis/issues/82
d$x.1 <- if_else(d$y < 0, 179, d$y)

e <- d[,c(4,6,2,3)]
str(e)
e <- df2move(e, proj = "+init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0", x = "x.1", y = "x", time = "timestamp", track_id = "V")
e@data$colour <- rep("black")#if do not want multicolour individuals

frames <- frames_spatial(e, path_colours = NA,
                         map_service = "osm", map_type = "watercolor", alpha = 0.5, path_legend = F, path_size = 2)

length(frames) # number of frames
frames[[2]] #quick check

animate_frames(frames, out_file = "./path/to/save/particle_movement_movie.mov", overwrite = T, fps = 7) #.gif takes longer
##########################################################################################
####PLOT A STATIC MAP####

#great tutorial on plotting with R - https://hansenjohnson.org/post/bathymetric-maps-in-r/

library(ggplot2)
library(mapdata)
library(mapproj)
library(marmap)

#could always add bathymetry
#Full NZ Map with points lon 155-180 and -180 to -165
#Issue with NZ: Longitudes should have values between -180 and +180 - so map splits in half if wanting to add contours
#NZMap <- getNOAA.bathy(lon1 = 155, lon2 = 180, lat1 = -30, lat2 = -55, resolution = 4)

# get regional polygons
reg = map_data("world2Hires")
#unique(reg$region)
reg = subset(reg, region %in% c('New Zealand'))

# set map limits
#Using map_data can extend past 180 and would just need to convert coords in df e to suit
#see d$x.1 <- if_else(d$y < 0, 179, d$y) above
lons = c(155, 180)
lats = c(-30, -55)

# make plot
ggplot()+
  
  # add coastline
  geom_polygon(data = reg, aes(x = long, y = lat, group = group), 
               fill = "darkgrey", color = NA) +
# add line
geom_path(data = e, aes(x = x.1, y = x, group = V),
          colour = "black", alpha = 1, size=0.3)+
  
  # add points
  geom_point(data = e, aes(x = x.1, y = x),
             colour = "black", fill = "grey", 
             stroke = .5, size = 2, 
             alpha = 1, shape = 21) +
  
  # configure projection and plot domain
  coord_map(xlim = lons, ylim = lats)+
  
  # formatting
  ylab("")+xlab("")+
  theme_bw()
#####################################################################################################################################
