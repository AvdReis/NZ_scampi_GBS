####PACKAGES####
library(readxl)
library(xlsx)
library(dplyr)
library(radiator)
library(ggplot2)
library(RColorBrewer)
library(mapplots)
library(fields)
library(LEA) #BiocManager::install(c("LEA"))
library(adegenet)
library(reshape2)
library(hierfstat)
library(ape)
library(pcadapt)
library(OutFLANK) #devtools::install_github("StoreyLab/qvalue") AND THEN devtools::install_github("whitlock/OutFLANK")
library(genepop)
library(strataG)
library(tidyr)
library(stackr) #devtools::install_github("thierrygosselin/stackr")
library(igraph)
library(StAMPP)
library(poppr)
library(DECIPHER)

####GENETIC DIVERSITY STATISTICS####

#here we are using the dataset that has been filtered
#loci_filtered_df - end product of Loci_depth_filtering in Data_filtering folder

#Ho, He and Fis#
hierf <- write_hierfstat(loci_filtered_df) #convert dataframe to hierfstat structure

hierf_stats <- basic.stats(hierf) #retrieve Ho, Hs and Fis from data

hierf_Ho <- as.data.frame(hierf_stats[["Ho"]])
hierf_Hs <- as.data.frame(hierf_stats[["Hs"]])
hierf_Fis <- as.data.frame(hierf_stats[["Fis"]])

#calculate the mean per area
hierf_Ho_mean <- hierf_Ho %>% gather("Area", "Ho", 1:5) %>% group_by(Area) %>% summarise(mean = mean(Ho)) %>% spread(1, 2, 2)
hierf_Hs_mean <- hierf_Hs %>% gather("Area", "Hs", 1:5) %>% group_by(Area) %>% summarise(mean = mean(Hs)) %>% spread(1, 2, 2)
hierf_Fis_mean <- hierf_Fis %>% gather("Area", "Fis", 1:5) %>% filter(Fis != "NaN") %>% group_by(Area) %>% summarise(mean = mean(Fis)) %>% spread(1, 2, 2)

Summary_table <- rbind(hierf_Ho_mean, hierf_Hs_mean, hierf_Fis_mean)

#Ar - allelic richness#

Ar <- allelic.richness(hierf,min.n=NULL,diploid=TRUE)
Ar <- as.data.frame(Ar$Ar)
Ar <- gather(Ar, "Area", "Ar", 1:n) #n = columns to gather
Ar <- aggregate(Ar~Area, Ar, mean)

#Pi - nucleotide diversity#

#nucleotide diversity - data from Stacks (populations.sumstats.tsv) - NB replicate removed prior to running populations again, this can just be done by removing the indiviual from the population file

populations.sumstats <- read.delim("/path/to/file/populations.sumstats.tsv", comment.char="#")

populations.sumstats <- rename(populations.sumstats, LOCUS = Locus.ID, POS = Col)
populations.sumstats$LOCUS <- as.character(populations.sumstats$LOCUS) #need loci to be read as character
populations.sumstats$POS <- populations.sumstats$POS +1 #To correct the POS need at add 1 is using SNP data
populations.sumstats$POS <- as.character(populations.sumstats$POS) #need SNP position to be read as character

Pi <- semi_join(populations.sumstats, loci_filtered_df, by = LOCUS) #select only those loci common between the dataframes and remove 'by = LOCUS' is using SNP data

mean_Pi <- aggregate(Pi~Pop.ID, Pi, mean) #If the sum is taken you get the haplotype diversity

####GENETIC DIFFERENTIATION####

#Fst#

Strata <- write_gtypes(loci_filtered_df)
StrataFst <- popStructTest(Strata, nrep = 100000, stats = "fst", type = "both", keep.null = FALSE, quietly = FALSE, max.cores = NULL)

#extract p-values and adjust
p.adjust(pvalue/s,method="fdr") #this can be done manually typing pvalues in or making an adjust pvalue column

#AMOVA#

poppr <- write_genind(loci_filtered_df)

#a way to define population hierarchy if needed - as an example
population_hierarchy <- c()
#note that this order is dependant on the order of your individuals in your data
population_hierarchy$Pop <- as.character(c(rep("state1", no_indv), rep("state2", no_indv), rep("state3", no_indv), rep("state1", no_indv), rep("state3", no_indv)))
population_hierarchy$Subpop <- as.character(c(rep("location_w/i_state1", no_indv), rep("location_w/i_state2", no_indv), rep("location_w/i_state3", no_indv), rep("location_w/i_state1", no_indv), rep("location_w/i_state3", no_indv)))
population_hierarchy <- as.data.frame(population_hierarchy)

#adding this info back into the poppr dataframe that was created
poppr$other$population_hierarchy <- population_hierarchy
strata(poppr) <- data.frame(other(poppr)$population_hierarchy)

poppr.gen <- as.genclone(poppr) #convert to genclone
poppr.amova <- poppr.amova(poppr.gen, hier = ~Pop, missing = "ignore", cutoff = "ignore", method = "ade4", clonecorrect = FALSE, within = FALSE, dist = NULL, squared = FALSE, freq = TRUE, correction = "quasieuclid", sep = "_", filter = FALSE, threshold = 0, algorithm = "farthest_neighbor", threads = 1L, quiet = FALSE)
set.seed(1000)
poppr_signif   <- randtest(poppr.amova, nrepet = 100000) #p.adjust.method = "bonferroni" only if using hierarchical populations

####GENETIC CLUSTERING####

#DAPC#
DAPC <- write_genind(loci_filtered_df)

mycol = col_choice = brewer.pal(5, "Dark2")

dapc1 <- dapc(DAPC, DAPC$pop, n.pca = 3, n.da = 2) #CHANGE PCs and 2 DFs - PCs graph and DFs
 
scatter(dapc1, col = mycol, cex = 2, legend = TRUE, clabel = F, posi.leg = "topright", scree.pca = TRUE,
        posi.pca = "topleft", posi.da = "bottomleft", cleg = 0.75)
        
#if want to get a structure-like plot using LEA#
write_structure(loci_filtered_df, parallel.core = 1, filename = "./structure")

structure <- read.delim("./structure.str", header=FALSE) #for some reason still keeping the header
str_df <- structure[2:173,] #remove header

str_df <- rename(str_df, "Individual" = "V1")
str_df$Individual <- as.character(str_df$Individual)

#prepare coordinate file (e.g., coords) where you have the individual's and the long and lat of their collection location and location name, and join to str_df
coords_str <- left_join(str_df, coords, by = "Individual")

#Need to bring Long and Lat to columns 1 and 2 for correct formatting of .str df. Remove column one that contains the names of the individuals.
coords_str <- coords_str[,c(986, 987, 2:985)] #these numbers will change depending on your data - c(long, lat, loci_1:loci_n)

write.table(coords_str, "./coords_str.str", sep="\t", row.names = FALSE, col.names = FALSE)

input.file = "./coords_str.str"

snmf <- struct2geno(input.file, ploidy = 2, FORMAT = 2, extra.row = 0, extra.column = 3) #return output file in console

#choose K values to investigate - e.g., K = 1:5
obj.snmf = snmf("coords_str.str.geno", K = 1:5, project = "new", repetitions = 100, CPU = 1, alpha = 200, tolerance = 0.00001, entropy = T, percentage = 0.05, iterations = 500, ploidy = 2, seed = 10)

plot(obj.snmf, col = "blue4", cex = 1.4, pch = 19) #ID best K value

#in this case K = 2 was the best value
best = which.min(cross.entropy(obj.snmf, K = 2))

qmatrix = Q(obj.snmf, K = 2, run = best)

#now need to get individuals name back and as df maintains same order they can just be pulled out again
idv_names <- structure[2:173,1]
idv_names <- unique(idv_names)
idv_names <- as.data.frame(idv_names)
idv_names$no <- as.character(rep(1:86))

qmat_df <- as.data.frame(qmatrix)
qmat_df$no <- row.names(qmat_df)

join <- left_join(qmat_df, idv_names)

names(join) <- c("Group1", "Group2", "no", "ind") #add as many groups as there are best K values

struc <- melt(join, id.vars=3:4) #id.vars needs to match "no" and "ind" columns
#can add locations using left join and df coords, and join by individuals. This will allow you to plot by location if you would like.

Set1 <- brewer.pal(8, "Set1")

ggplot(struc, aes(ind, value, fill = variable)) +
  geom_bar(stat = "identity") +
  scale_fill_brewer(palette = "Set1") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  xlab("Individual") +
  ylab("Admixture coefficients")
