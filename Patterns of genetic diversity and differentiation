####PACKAGES####
library(readxl)
library(xlsx)
library(dplyr)
library(radiator)
library(ggplot2)
library(RColorBrewer)
library(mapplots)
library(fields)
library(LEA) #BiocManager::install(c("LEA"))
library(adegenet)
library(reshape2)
library(hierfstat)
library(ape)
library(pcadapt)
library(OutFLANK) #devtools::install_github("StoreyLab/qvalue") AND THEN devtools::install_github("whitlock/OutFLANK")
library(genepop)
library(strataG)
library(tidyr)
library(stackr) #devtools::install_github("thierrygosselin/stackr")
library(igraph)
library(StAMPP)
library(poppr)
library(DECIPHER)

####GENETIC DIVERSITY STATISTICS####

#here we are using the dataset that has been filtered
#loci_filtered_df - end product of Loci_depth_filtering in Data_filtering folder

#Ho, He and Fis#
hierf <- write_hierfstat(loci_filtered_df) #convert dataframe to hierfstat structure

hierf_stats <- basic.stats(hierf) #retrieve Ho, Hs and Fis from data

hierf_Ho <- as.data.frame(hierf_stats[["Ho"]])
hierf_Hs <- as.data.frame(hierf_stats[["Hs"]])
hierf_Fis <- as.data.frame(hierf_stats[["Fis"]])

#calculate the mean per area
hierf_Ho_mean <- hierf_Ho %>% gather("Area", "Ho", 1:5) %>% group_by(Area) %>% summarise(mean = mean(Ho)) %>% spread(1, 2, 2)
hierf_Hs_mean <- hierf_Hs %>% gather("Area", "Hs", 1:5) %>% group_by(Area) %>% summarise(mean = mean(Hs)) %>% spread(1, 2, 2)
hierf_Fis_mean <- hierf_Fis %>% gather("Area", "Fis", 1:5) %>% filter(Fis != "NaN") %>% group_by(Area) %>% summarise(mean = mean(Fis)) %>% spread(1, 2, 2)

Summary_table <- rbind(hierf_Ho_mean, hierf_Hs_mean, hierf_Fis_mean)

#Ar - allelic richness#

Ar <- allelic.richness(hierf,min.n=NULL,diploid=TRUE)
Ar <- as.data.frame(Ar$Ar)
Ar <- gather(Ar, "Area", "Ar", 1:n) #n = columns to gather
Ar <- aggregate(Ar~Area, Ar, mean)

#Pi - nucleotide diversity#

#nucleotide diversity - data from Stacks (populations.sumstats.tsv) - NB replicate removed prior to running populations again, this can just be done by removing the indiviual from the population file

populations.sumstats <- read.delim("/path/to/file/populations.sumstats.tsv", comment.char="#")

populations.sumstats <- rename(populations.sumstats, LOCUS = Locus.ID, POS = Col)
populations.sumstats$LOCUS <- as.character(populations.sumstats$LOCUS) #need loci to be read as character
populations.sumstats$POS <- populations.sumstats$POS +1 #To correct the POS need at add 1 is using SNP data
populations.sumstats$POS <- as.character(populations.sumstats$POS) #need SNP position to be read as character

Pi <- semi_join(populations.sumstats, loci_filtered_df, by = LOCUS) #select only those loci common between the dataframes and remove 'by = LOCUS' is using SNP data

mean_Pi <- aggregate(Pi~Pop.ID, Pi, mean) #If the sum is taken you get the haplotype diversity

####GENETIC DIFFERENTIATION####

#Fst#

Strata <- write_gtypes(loci_filtered_df)
StrataFst <- popStructTest(Strata, nrep = 100000, stats = "fst", type = "both", keep.null = FALSE, quietly = FALSE, max.cores = NULL)

#extract p-values and adjust
p.adjust(pvalue/s,method="fdr") #this can be done manually typing pvalues in or making an adjust pvalue column

#AMOVA#

poppr <- write_genind(loci_filtered_df)

#a way to define population hierarchy if needed - as an example
population_hierarchy <- c()
#note that this order is dependant on the order of your individuals in your data
population_hierarchy$Pop <- as.character(c(rep("state1", no_indv), rep("state2", no_indv), rep("state3", no_indv), rep("state1", no_indv), rep("state3", no_indv)))
population_hierarchy$Subpop <- as.character(c(rep("location_w/i_state1", no_indv), rep("location_w/i_state2", no_indv), rep("location_w/i_state3", no_indv), rep("location_w/i_state1", no_indv), rep("location_w/i_state3", no_indv)))
population_hierarchy <- as.data.frame(population_hierarchy)

#adding this info back into the poppr dataframe that was created
poppr$other$population_hierarchy <- population_hierarchy
strata(poppr) <- data.frame(other(poppr)$population_hierarchy)

poppr.gen <- as.genclone(poppr) #convert to genclone
poppr.amova <- poppr.amova(poppr.gen, hier = ~Pop, missing = "ignore", cutoff = "ignore", method = "ade4", clonecorrect = FALSE, within = FALSE, dist = NULL, squared = FALSE, freq = TRUE, correction = "quasieuclid", sep = "_", filter = FALSE, threshold = 0, algorithm = "farthest_neighbor", threads = 1L, quiet = FALSE)
set.seed(1000)
poppr_signif   <- randtest(poppr.amova, nrepet = 100000) #p.adjust.method = "bonferroni" only if using hierarchical populations

####GENETIC CLUSTERING####


